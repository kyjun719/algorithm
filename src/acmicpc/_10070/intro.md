#### 문제를 읽고 이해하기
https://www.acmicpc.net/problem/10070

input</br>
10 6
1 1 8 4
2 4 9 1
2 3 6 5
1 0 5 3
1 2 2 5
2 6 7 0


output</br>
3
4
5
4
3
3
0
0
1
0


#### 재정의와 추상화<br>
-- 문제를 읽고 본인이 이해하기 쉬운 방식으로 해석<br>
두가지 연산을 통해 만들어진 블록의 최종높이

#### 계획 세우기<br>
더하는 단계는 해당값이 범위의 최소높이가 되고, 빼는 단계는 해당값의 범위의 최대높이가 됨.

연산의 갯수가 많으므로 lazy propagation을 사용함.  
업데이트 가능성이 없는경우 종료함.  

최소값과 최대값에 대한 lazy 배열을 만들고 다음과 같이 업데이트함.  
-> 연산을 통해 부모의 범위가 정해진 경우 자식에게도 이 범위를 전파해야함. 따라서 자식노드는 부모노드의 범위내에 존재하게함.  
-> 따라서 자식노드의 범위는 부모노드의 최소값보다 크고 최대값보다 작아야함  
--> 부모노드의 최소값으로 자식노드에 더하기연산을 처리하고, 

리프노드에 도달했을때는 입력받은 연산을 가지고 값을 업데이트함.   
-> 더하기 연산에서는 해당값이 범위의 최소값이고, 빼기연산은 해당값이 범위의 최대값임.  
-> 연산 후 리프노드 범위의 최소값을 정답으로 저장함


#### 계획 검증하기
https://justicehui.github.io/ioi/2019/10/03/BOJ10070/
